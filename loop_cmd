#!/bin/bash
# loop_cmd
#
#    Given a shell command, this puts it into an endless loop with a continuation prompt at the end of each iteration.
#
#   e.g.:
#
#   $  loop_cmd cmd arg1 arg2 arg3   # Run cmd with its args over and over, prompting for restart each time.
#
#  or...
#
#  $ loop_cmd <<< "echo \$(date)"
# 
# Advanced:  If you'd like to have this as a function in your login shell (so you can use it with internal
# shell commands too), add this to ~/.bashrc:
# 
#     sourceMe=1 source /path/to/loop_cmd/script
#

color_red="\033[;31m"
color_green="\033[;32m"
color_yellow="\033[;33m"
color_none="\033[;0m"
loopcmd_configdir=$HOME/.config/loop_cmd.d

function die {
    echo "ERROR: $@" >&2
    exit 1
}

function loop_edit {
    which vipe &>/dev/null || return $(die vipe not available, sorry)
    echo "$@" | vipe
}

function loop_show {
    echo -e "${color_green}Command is: [${color_none}${cmd}${color_green}]"
    echo -e "Named as: ${color_none}${cmd_name}"
}

function update_loopcmd_name {
    mkdir -p ${loopcmd_configdir}
    echo -ne "${color_green}
  --> Assign a name to this command: ${color_none}" >&2
    read -e -i "$1" 
    if [[ -z $REPLY ]]; then
        return 1
    fi
    echo "$cmd" > ${loopcmd_configdir}/$REPLY
    echo -e "  ${color_green}--> (Command was saved as ${color_none}$loopcmd_configdir/$REPLY${color_green})" >&2
    echo "$REPLY"
}


function loop_cmd {
    if [[ $1 == -r ]]; then 
        # Re-run a named command from ~/.config/loop_cmd.d:
        shift
        cmd_name=$1
        [[ -f $loopcmd_configdir/${cmd_name} ]] || return $(die cant find ${loopcmd_configdir}/${cmd_name})
        cmd="$(cat $loopcmd_configdir/${cmd_name})"
        shift
    else
        # First arg is command to run:
        cmd=$1
        shift
        if [[ -z $cmd ]]; then
            cmd="$(loop_edit '# Enter loop command:
    ')"
        fi
    fi
    nloop=1
    while true; do
        eval "$cmd $@"
        res=$?
        if (( res == 0 )); then
            echo -e "${color_yellow}<<-- loop_cmd[${nloop}]: ${color_green}OK${color_none}" 
        else
            echo -e "${color_yellow}<<-- loop_cmd[${nloop}]: ${color_red}FAIL: $res 
    ${color_yellow}Command was: [${color_none}$cmd${color_yellow}]"
        fi

        while true; do
            echo -ne "${color_yellow}[A]gain, [E]dit, [S]how, [N]ame+save or [Q]uit:${color_none}"
            
            read -n 1  </dev/tty
            case $REPLY in
                q|Q) 
                    return $?;
                    ;;
                a|A)
                    unset REPLY
                    echo ""
                    break;
                    ;;
                e|E)
                    cmd=$(loop_edit "$cmd")
                    echo ""
                    unset REPLY
                    break
                    ;;
                s|S)
                    echo ""
                    loop_show
                    continue
                    ;;
                n|N)
                    cmd_name=$(update_loopcmd_name "$cmd_name")
                    unset REPLY
                    echo ""
                    continue
                    ;;

                *)
                    echo -e "${color_red} -->> loop_cmd doesn't understand: $REPLY${color_none}"
                    unset REPLY
                    ;;
            esac
        done

    (( nloop = $nloop + 1 ))
    done
}

if [[ -z $sourceMe ]]; then
    loop_cmd "$@"
fi

