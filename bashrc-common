#!/bin/bash

[[ -z $LmHome ]] && export LmHome=$HOME

alias pathadd=$LmHome/bin/pathadd

function isSunos {
    if [[ $(uname) == "SunOS" ]]; then
        true
        return
    fi
    false
}


#----------------------------------------------------------------
#  Shell identification
#
function shell_identify {
	export CYGWIN=false
	export MACOSX=false
	if [[ -n "$ZSH_VERSION" ]]; then
		inZsh=true
		eval "function shopt {
			local doNothing
			# turn shopt into nothingness in zsh
		}"
	else
		inZsh=false
	fi

	[[ -f /Cygwin.bat ]] && CYGWIN=true

	[[ -d /Applications/Preview.app ]] && MACOSX=true

	# We treat Mobaterm as cygwin too:
    [[ -d /home/mobaxterm ]]  && CYGWIN=true

	# If not running interactively, don't do anything
	if [[ ! -t 0 ]]; then
		return
	fi
}

shell_identify

function fix_PATH {
    origPath=$PATH
    # These dirs are listed from most-general to most-specific. This wipes out any previous path, and  inserts
    # the most-specific dirs ahead of the least-specfic:
    for xd in /bin /sbin /usr/bin /usr/sbin /usr/local/bin /bb/bin /opt/swt/bin /opt/bb/bin  $LmHome/mylibs/${lmPlatform}/bin $LmHome/bin $LmHome/binl  $LmHome/bin/localsys $cygPathAdd; do
        if [[ -d $xd ]]; then
            PATH=$xd:$PATH
        fi
    done

    PATH=$($LmHome/bin/path_undupe $PATH:$origPath)
    unset origPath
}

fix_PATH  # Also call this at the end of bashrc

#----------------------------------------------------------------


alias which='type -p '


umask 0022
IGNOREEOF="3"   # Don't close interactive shell for ^D


function ptop {
    # Run top, but filter on a specific command line string, e.g.:
    #
    #     $  ptop my_busy_proc
    #

    local cmd=$1
    top -p $(pgrep ${cmd} | head -n 19 | tr '\n' ',')0
}


function histrc {
    
	# don't put duplicate lines in the history. See bash(1) for more options
	# ... or force ignoredups and ignorespace
	HISTCONTROL=ignoredups:ignorespace


	# append to the history file, don't overwrite it
	shopt -s histappend
	shopt -s histverify # Load history events for editing rather than immediate execution
	# for setting history length see HISTSIZE and HISTFILESIZE in bash(1)
	HISTSIZE=10000
	HISTFILESIZE=20000
	PROMPT_COMMAND='history -n'

	alias hist='history '
	alias hn='histNote '
	alias hl='histNote -l'
	alias hisg='history | grep '
	export PROMPT_COMMAND="history -a"
	
	# Write a note to the bash history.  -l means 'list histNotes'.
	function histNote {
		if [[ "$1" == "-l" ]]; then
			history | egrep -A 2 '#--histNote'
		else
			history -s "#--histNote------------H-I-S-T-N-O-T-E--$(date):"
			history -s "cd $PWD"
			history -s "$@"
			history -s "# . . ."
		fi
	}
}

histrc


TERM=xterm-256color

function initLsStuff {
	# some more ls aliases
	alias ll='ls -alF'
	alias la='ls -A'
	alias l='ls -CF'
	alias l1='ls -1'
	alias lr='ls -lirt'
	if $MACOSX; then   # Mac doesn't have dircolors
		CLICOLOR=YES
		alias ls='ls -G'
	else
		eval $(dircolors)
		alias ls='ls --color=auto '
	fi
}
	

initLsStuff

# check the window size after each command and, if necessary,
# update the values of LINES and COLUMNS.
shopt -s checkwinsize




function initGitStuff {

	alias gs='git status --porcelain'
	alias gc='git commit'
	alias ga='git add'
	alias gp='git push'
	alias gl='git log'
	alias gpull='git pull'
	alias gd='git diff'
	alias gdt='git difftool'
	alias gitg='git ls-files | grep'

	source ${LmHome}/bin/git-completion.bash

}

initGitStuff

function rdp_connect {
	# Base code for connecting to an RDP server with rdesktop
	local xhost=$1
	local xuser=$2
	local xpwd=$3
	rdesktop -u $xuser -p "$xpwd" -g 1366x768 -K -x lan $xhost &
}

# Set the terminal title (tmux only)
function title {
#	echo -ne "\033]0;${1}\007" 

    printf '\033]2;%s\033\\' "$*"
}

# See tmux-attach for set_DISPLAY:
function setDisplay {
    [[ -f ~/tmp/set_DISPLAY ]] || { echo "ERROR: no ~/tmp/set_DISPLAY script found." ; false; return; }
    source ~/tmp/set_DISPLAY
    echo "DISPLAY=$DISPLAY"
}

[[ -f ~/bin/bash_aliases ]] && source ~/bin/bash_aliases

if $CYGWIN; then
	source ~/bin/cyg/cyg-utils
	alias sudo="$@"
fi

if ! $inZsh; then
	if [ -f /etc/bash_completion ] && ! shopt -oq posix; then
		. /etc/bash_completion
	fi
fi


export EDITOR=$(which vim)
if ! which gvim &>/dev/null; then
    alias gvim=vim
fi
export XEDITOR=$EDITOR

alias vimgit='vim $(git ls-files) '

# disable flow control for terminal:
stty -ixon -ixoff

# Magic space expands !! and !-{n} when you hit spacebar after.  You can also do
# {cmd-frag}!<space> to expand the last command that started with that frag.
bind Space:magic-space


if $CYGWIN; then
    export DISPLAY=:0
    cygPathAdd=$LmHome/bin/cyg
fi




# Restart network to fix wifi on Kubuntu roaming:
function wifi-restart {
	echo "Restarting wpa_supplicant and network-manager:"
	sudo killall wpa_supplicant
	sudo rfkill unblock all
	sudo service network-manager restart
	while !  ping 8.8.8.8 -c 1; do
		sleep 1
	done
}

# Show ip address of given NIC
function ip-show {
	ip addr show dev $1
}

# If we want a shell to not quit, here's how:
function no-exit {
	alias exit="echo 'Sorry, exit is disabled.  Use \"command exit\" if  serious'"
}

if [[ -f ${LmHome}/bin/rbuzz_rcd ]]; then
	function tox {
	    while [[ ! -z $1 ]]; do
            local arg1=$1
            shift
            if [[ $1 =~ ^[0-9]+$ ]]; then
                local offset=${1} # If we match a number, interpret it as an offset in a list of matching dirs
                shift
            fi
            #echo "stub0: [$arg1] [$offset]" >&2
            local newDir="$($LmHome/bin/rbuzz_rcd ${arg1} ${offset} )"
            if [[ "${newDir:0:1}" == "!" ]]; then
                # rbuzz_rcd returned a command and we should run it:
                eval "${newDir:1}"
            elif [[ ! -z "$newDir" ]]; then
                pushd $newDir >/dev/null
            fi
        done
	}
else
	function tox {
		echo "This function only works if ${LmHome}/bin/rbuzz_rcd is present."
	}
fi


function printPs1 {
    local dx
    local sx="${HOSTNAME/sundev/sd}"  # Abbreviate server names
    sx="${sx/linxdev/lx}"
    sx="${sx/lxdev/lx}"

    if [[ -z $PS1_KEEP_HOME ]]; then
        dx="${PWD/#$HOME/~}"   # Swap out home dir
    fi
    echo "$sx:$shell_id $dx\$ "
}

function setOldPs1 {
    export MYPS='$(echo -n "${PWD/#$HOME/~}" | awk -F "/" '"'"'{if (length($0) > 14) { if (NF>4) print $1 "/" $2 "/.../" $(NF-1) "/" $NF; else if (NF>3) print $1 "/" $2 "/.../" $NF; else print $1 "/.../" $NF; } else print $0;}'"'"')'
    PS1='$(eval "echo ${MYPS}")$ '
}

function setFancyPs1 {
PS1='
\[\033[1;33m\][\D{%Y-%m-%d %H:%M.%S}]\[\033[0m\]  \[\033[1;35m\]\w\[\033[0m\]
\[\033[1;36m\][\u.\h]\[\033[0m\] > '
}

#PS1='$(printPs1)'
setFancyPs1

#setPs1


function loadTaskrcs {
	function load_rcs1 {
	    local rootDir=$1
        /bin/ls -1 ${rootDir}/.taskrc/* 2>/dev/null | egrep -v '\.vim$' | sort
    }

	# Load everything in $HOME/.taskrc, sorting alpha.  Most
	# of these should be symlinks.
	while read line; do
		if [[ -f $line ]]; then 
            source $line
        fi
    done < <( load_rcs1 "$HOME" )

	# Do it for any local .taskrc's in current dir also:
	if [[ "$HOME" != "$PWD" ]]; then
        while read line; do
            if [[ -f $line ]]; then 
                source $line
            fi
        done < <( load_rcs1 "$PWD" )
    fi
}

function reset {
    # The standard reset doesn't restore the cursor, necessarily.
    setterm -cursor on
    command reset
}

unalias rm 2>/dev/null # If someone aliased my rm, cut it out.

export MYLIBS=${LmHome}/mylibs/$(uname)
alias cd-mylibs='cd $MYLIBS'

#
# Make tmux use 256 colors so vim highlighting works right:
alias tmux='tmux -2'
alias tmux-detach='tmux detach'



fix_PATH

# Mildly cleaner taskrc.  If there's a .taskrc directory in HOME,
# just source everything found there.
if [[ -d $HOME/.taskrc ]]; then
	loadTaskrcs
fi

