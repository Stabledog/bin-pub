#!/bin/bash
# loop_cmd
#
#    Given a shell command, this puts it into an endless loop with a continuation prompt at the end of each iteration.
#
#   e.g.:
#
#   $  loop_cmd cmd arg1 arg2 arg3   # Run cmd with its args over and over, prompting for restart each time.
#
#  or...
#
#  $ loop_cmd <<< "echo \$(date)"
# 
# Advanced:  If you'd like to have this as a function in your login shell (so you can use it with internal
# shell commands too), add this to ~/.bashrc:
# 
#     sourceMe=1 source /path/to/loop_cmd/script
#


function loop_cmd {
    cmd=$1
    shift
    if [[ -z $cmd ]]; then
        echo -ne "\033[;32mEnter command to loop, then Ctrl+D: \033[;0m"
        cmd=$(cat) 
    fi
    nloop=1
    while true; do
        $cmd "$@"
        res=$?
        echo -e "\033[;33m<<-- loop_cmd[${nloop}], program returned $res.  Command was: "  
        echo -e " -->> [\033[;32m$cmd $@\033[;33m]"  

        while true; do
            echo -ne "\033[;33m[A]gain or [Q]uit:\033[;0m"
            
            read -n 1  </dev/tty
            case $REPLY in
                q|Q) 
                    return $?;
                    ;;
                a|A)
                    unset REPLY
                    echo ""
                    break;
                    ;;
                *)
                    echo -e "\033[;31m -->> loop_cmd doesn't understand: $REPLY\033[;0m"
                    unset REPLY
                    ;;
            esac
        done

    (( nloop = $nloop + 1 ))
    done
}

if [[ -z $sourceMe ]]; then
    loop_cmd "$@"
fi

