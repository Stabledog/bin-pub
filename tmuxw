#!/bin/bash
#   Usage:
#       tmuxw my-session
#              > start 'my-session' or attach to running session
#       tmux
#              > List running sessions. User chooses one to attach or creates new from prompt
#       tmuxw ls [args]
#              > Pass through for [ls,a,attach,new-session]

function errExit {
    echo "ERROR: $@" >&2
    exit 1
}

tmux=$(which tmux)
shopt -s extglob

function launch_or_attach {
    local tgt_session_name="$1"
    shift
    # Is this session running already?
    if tmux ls | awk '{print $1}' | grep -qF "${tgt_session_name}:"; then
        echo "Session ${tgt_session_name} found, attaching:"
        tmux attach -t "${tgt_session_name}" "$@"
    else
        echo "Session ${tgt_session_name} not found: creating new"
        tmux new-session -s "${tgt_session_name}" "$@"
    fi
}

function dispatch_args {
    local tgt_session_name
    while [[ ! -z $1 ]]; do
        case $1 in
            ls|a|attach|new-session)
                command $tmux $@
                exit $?
                ;;

            # Identifying session names, we enforce a few restrictions, the
            # tmux-permitted pattern is more generous than this:
            @([a-zA-Z0-9]*([a-zA-Z0-9_.@\-/^%])) )
                tgt_session_name="$1"
                launch_or_attach "$tgt_session_name"
                ;;

            *)
                echo "Unknown argument: $1"
                break
                ;;
        esac
        shift
    done
}

function match_session_name {
    # Match $1 against an existing session name, print the whole name.  Partial
    # matches may produce multiple candidates, so expect multiple lines or empty results.
}

function interactive {

    while true; do
        tmux ls | cat -n
        read -p "Choose entry by number or session name match: "
        case "$REPLY" in
            +([0-9]) )
                echo "match number $REPLY"
                ;;
            *)
                echo "match name $REPLY"
                tgt_session_name=$(match_session_name "$REPLY")
                ;;
        esac
    done
}

if [[ -z $sourceMe ]]; then
    dispatch_args  "$@"
    # if dispatch_args doesn't do the job, run our picker:
    interactive "$@"
fi
